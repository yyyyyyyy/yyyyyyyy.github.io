---
layout: post
date:   2018-10-04 13:36:31 +0800
categories: 
---
## 垃圾回收（Garbage Collection）
了解GC可以分4块内容：
​    
    1. JVM逻辑内存模型
    2. GC Roots Tracing
    3. GC 常用算法
    4. GC 收集器
## 一、JVM逻辑内存模型
首先，我们先了解一下JVM逻辑内存模型。
### 程序计数器
程序计数器（PC寄存器）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。

在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

每条线程都有一个独立的程序计数器，各条线程之间额计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，这个计数器值为空。

此内存区域是唯一一个在JVM规范中没有规定OutOfMemoryError情况的区域。
### Java虚拟机栈
与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型。

每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
​    
    * 局部变量表
局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型（指向了一条字节码指令的地址）；包括this引用，对于类方法，方法参数从下标0开始，对于对象方法，位置0保留为this。其中64位长度的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。

局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常；如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。
​    
    * 操作数栈：在执行字节码指令的时候使用，类似CPU寄存器。
    * 动态链接：类当前方法的运行时常量池引用。
    * 方法出口
### 本地方法栈

本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的Native方法服务。

与虚拟机栈一样，本地方法栈区域也会抛出StackOverFlowError和OutOfMemoryError异常。

### Java堆

此内存区域的唯一目的就是存放对象实力，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在对上分配。

Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”。由于现在收集器基本都是采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。

根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。

如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。
### 方法区

方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据。

根据Java虚拟机规范的规定，当方法区无法满足的内存分配需求时，将抛出OutOfMemoryError异常。

### 运行时常量池

运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

### 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁的使用，而且可以导致OutOfMemoryError异常出现。

在JDK1.4中新加入了NIO类，引入了一种基于Channel与Buffer的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM及SWAP区或者分页文件）的大小及处理器寻址空间的限制。

## 二、GC Roots Tracing
如何判断实例是否还应该被GC呢？

	1. 引用计数法：
给对象添加一个引用计数器，当有一个地方引用它就在计数器上+1，当一个引用失效计数器-1。当计数器为0是我们认为此对象实例不再被使用，可以被回收。但是此方法有一个问题，无法解决相互引用问题。

	2. GC Roots可达性算法：
通过可以做为"GC Roots"的对象作为根结点，向下搜索，没有引用链相连的对象我们认为可以被回收。
​    
    GC Roots包括：
    * 栈中引用的对象
    * 方法区中静态常量引用的对象
    * 方法区中静态属性引用的对象
    * Native方法中引用的对象

## 三、GC 常用算法
    1. 标记-清除算法：
分为两个阶段，第一阶段标记出所有存活的对象，第二阶段堆未被标记的对象进行回收。标记-清除算法的缺点是会造成产生许多不连续的空间。
​    
    2. 复制算法：
将回收区域分为相同的两块，每次使用一块。将存活的对象复制到另一块区域，然后将使用过的区域一次性清理掉。复制算法的缺点是将内存空间缩小到一半。

    3. 标记-整理算法：
标记-整理算法是在标记-清除算法上做了改进，第一阶段也是标记出所有存活的对象，第二阶段是将所有存活的对象都移动到一侧，然后再清除掉边界以外的所有对象。标记-整理算法的缺点是在整理阶段要花费一些时间。

    4. 分代收集算法：
根据内存中对象的存活周期不同，将内存分为几块使用合适的算法。

    5. 火车算法：
火车算法把成熟对象空间划分为固定长度的内存块，算法每次在一个块中单独执行。每个块属于一个集合。

## 四、GC 收集器
    1. Serial收集器：Serial（串行）收集器是最古老的收集器，它的缺点是当Serial收集器想进行垃圾回收的时候，必须暂停用户的所有进程，即"Stop The World"，采用的是复制算法   
    2. Serial Old收集器：Serial收集器的老年代版本，采用的是标记-整理算法。
    3. ParNew收集器：ParNew收集器是Serial收集器的多线程实现，在GC的时候依然会"Stop The World"。
    4. Parallel Scavenge收集器：Parallel Scavenge收集器关注的是吞吐量（高效利用CPU）。采用的是复制算法。
    5. Parallel Old收集器：Parallel Scavenge收集器的老年代实现。使用的是标记-整理算法。
    6. CMS收集器：CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
        * 步骤：
            1. 初始标记：仅标记一下GC Roots能直接关联到的对象；速度很快；但需要"Stop The World"。
            2. 并发标记：进行GC Roots Tracing，标记出存活对象，应用程序也在运行；并不能保证可以标记出所有存活对象。
            3. 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象。需要"Stop The World"，且停顿时间比初始标记稍长，但远比并发标记短；采用多线程并行来提升效率。
            4. 并发清除：回收所有的垃圾对象。
        * 缺点：
            1. 对CPU资源非常敏感：虽然不会暂停用户线程，但因为占用一部分CPU资源，还是会导致应用程序变慢。
            2. 无法处理浮动垃圾（并发清除是产生的垃圾），可能出现"Concurrent Mode Failure（CMS预留内存空间无法满足程序需要）"失败。这时JVM启用后备预案：临时启用Serial Old收集器，而导致另一次Full GC。
            3. 产生大量内存碎片：使用标记-清除算法会产生不连续内存，无法找到足够连续空间会提前触发Full GC。
    
    7. G1：G1（Garbage-First）是JDK7-u4才推出商用的收集器。  
        * 特点：
            1. 并行与并发：充分利用CPU、多核环境下的硬件优势；可以并行来缩短"Stop The World"停顿时间；也可以并发让垃圾收集与用户程序同时进行。
            2. 分代收集，收集范围包括新生代和老年代：能独立管理整个GC堆，而不需要与其他收集器搭配；能够采用不同方式处理不同时期的对象；虽然保留分代概念，但Java堆的内存布局有很大差别；将整个堆划分为多个大小相等的独立区域；
            3. 结合多种垃圾收集算法，空间整合，不产生碎片：从整体上看，是基于标记-整理算法；从局部看（两个Region间），是基于复制算法；是一种类似火车算法的实现；都不会产生碎片，有利于长时间运行；
            4. 可预测的停顿：低停顿的同时实现高吞吐量。
        * G1收集器运作过程：
            1. 初始标记：仅标记一下GC Roots能直接关联到的对象；
            2. 并发标记：进行GC Roots Tracing的过程；在刚才产生的集合中标记出存活对象；
            3. 最终标记：为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象。
            4. 筛选回收：首先排序各个Region的回收价值和成本；然后根据用户期望的GC停顿时间来指定回收计划。最后按计划回收一些价值高的Region中垃圾对象；
    8. ZGC:
        1. 所有阶段几乎都是并发执行的，就是还有三个非常短暂的STW阶段，所以ZGC并不是Zero Pause GC。
        2. 并发执行的保证机制，就是Colored Pointer和Load Barrier。Colored Pointer从64位的指针中，借了几位出来表示Finalizable、Remapped、Marked1、Marked0。所以不支持32位指针，也不支持压缩指针，且堆的上限是4TB。
        3. 像G1一样划分Region，但更加灵活：ZGC将堆划分为Region作为清理，移动，以及并行GC线程工作分配的单位。
        4. 和G1一样会做Compacting-压缩
        5. Remap-修正指针：最后将指针都妥帖的更新指向新地址。
        6. 没有G1占内存的Remember Set，没有Write Barrier的开销
        7. 支持Numa架构
        8. 并行
        9. 单代