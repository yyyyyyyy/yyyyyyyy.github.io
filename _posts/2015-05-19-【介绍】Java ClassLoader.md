---
layout: post
title:  "Java ClassLoader"
date:   2015-05-19 00:01:00 +0800
categories: 
comments: true
excerpt: 
---
## 类加载（ClassLoader）
* 加载：查找并加载类的二进制数据
    * 通过一个类的全限定名来获取其定义的二进制字节流。
    * 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    * 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。
* 链接：
    * 验证：确保被加载类的正确性。
        * 文件格式验证：验证字节流是否符合Class文件格式的规范。
        * 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。
        * 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
        * 符号引用验证：确保解析动作能正确执行。
    验证阶段是非常重要的，但不是必须的。
    * 准备：为类的静态变量分配内存，并将其初始化为默认值
        * 这时候进行内存分配的仅包括类变量，而不包括实例变量。
        * 这里所设置的初始值通常情况下是数据类型默认的零值，而不是在Java代码中显式赋予的值。
        * 如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。
    * 解析：将类中的符号引用转换为直接引用。
* 初始化：为类的静态变量赋予正确的初始值。

JVM初始化步骤：
* 假如这个类还没有被加载和链接，则程序先加载并连接该类。
* 假如该类的直接父类还没有被初始化，则先初始化其直接父类。
* 假如类中有初始化语句，则系统依次执行这些初始化语句。

类初始化的时机：
* 创建类的实例，也就是new的方式。
* 访问某个类或接口的静态变量，或者对该静态变量赋值。
* 调用类的静态方法。
* 反射（如Class.forName("")）。
* 初始化某个类的子类，则其父类也会被初始化。
* Java虚拟机启动时被标明为启动类的类。

结束生命周期：
* 执行了System.exit()方法。
* 程序正常执行结束。
* 程序在执行过程中遇到类异常或错误而异常终止。
* 由于操作系统出现错误而导致Java虚拟机进程终止。

### 类加载器
启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib下，或被-Xbootclasspath参数指定路径中的，并且能被虚拟机识别的类库。

扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定路径中的所有类库。

应用程序类加载器：Application ClassLoader，该类由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类。

JVM类加载机制

全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入。

父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。

缓存机制，缓存机制将会保证多有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。

### 类的加载
* 命令行启动应用时候由JVM初始化加载
* 通过Class.forName()方法动态加载
* 通过ClassLoader.loadClass()方法动态加载

### 双亲委派模型
如果一个类加载器收到了类加载的请求，它首先不会自己区尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中。
* 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
* 当ExtClassLoader加载一个class是，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
* 若果BootStrapClassLoader加载失败，会使用ExtClassLoader来尝试加载。
* 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。

双亲委派模型的意义：
* 系统类防止内存中出现多分同样的字节码
* 保证Java程序安全稳定运行

### 自定义类加载器
自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。