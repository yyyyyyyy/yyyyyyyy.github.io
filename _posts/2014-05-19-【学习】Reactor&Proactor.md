---
layout: post
title:  "【学习】Reactor&Proactor"
date:   2014-05-19 00:00:00 +0800
categories: 
---

> 一般情况下，I/O多路复用机制都依赖于一个事件多路分离器（Event Demultiplexer）。分离器对象可将来自事件源的I/O事件分离出来，并分发到对应的read/write事件处理器(Event Handler) 。

### 同步？异步？阻塞？非阻塞？

学习Reactor&Proactor首先要先了解一些概念，什么是同步？什么是异步？什么是阻塞？什么是非阻塞？

>下面是在网上找到的解释，说的很明白了。（找了好多，发现都是这一套，也不知道出自谁手~）
> * 同步与异步是针对应用程序与内核的交互而言的。同步过程中进程触发I/O操作并等待或者轮询的去查看I/O操作是否完成。异步过程中进程触发I/O操作以后，直接返回，做自己的事情，I/O交给内核来处理，完成后内核通知进程I/O完成 
> *  应用进程请求I/O操作时，如果数据未准备好，如果请求立即返回就是非阻塞，不立即返回就是阻塞。简单说就是做一件事如果不能立即获得返回，需要等待，就是阻塞，否则就可以理解为非阻塞。 

### I/O模型

> 所有的系统I/O都分为两个阶段：等待就绪和操作。举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。
>
> 需要说明的是等待就绪的阻塞是不使用CPU的，是在“空等”；而真正的读写操作的阻塞是使用CPU的，真正在"干活"，而且这个过程非常快，属于memory copy，带宽通常在1GB/s级别以上，可以理解为基本不耗时。
>
> 同步阻塞：
>
> 在传统的BIO中socket.read()，如果TCP RecvBuffer里面没有数据，函数会一直阻塞，知道收到数据，返回读到的数据。
>
> 同步非阻塞：
>
> 对于NIO，如果TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回；反之返回0，永远不会阻塞。
>
> 异步非阻塞
>
> AIO（NIO2.0）在NIO的基础上引入了异步通道的概念，并提供了异步文件和异步套接字的实现，从而在真正意义上实现了异步非阻塞。

## Reactor

Reactor模式采用的是同步I/O。

在Reactor中，事件分离器等待某个事件或者某个操作状态发生，事件分离器将这个事件传给事先注册的事件处理函数或者回调函数，然后由后者来做实际的读写操作。

标准的经典Reactor模式：

* 等待事件（Reactor的工作）
* 将“已经可读”的事件发给事先注册的事件处理者或者回调（Reactor的工作）
* 读取数据（用户的工作）
* 处理数据（用户的工作）

Reactor模式关心的是动作是否发生，至于发生后要这么处理是需要用户来操作的。

## Proactor

Proactor模式采用的是异步非阻塞I/O。

在Proactor模式中，事件处理器直接发起一个异步读写操作（注意：操作系统必须支持异步IO） ，而实际的工作是由操作系统来完成的。发起时，需要提供数据缓存区，读的数据大小；或者用于存放外发数据的缓存区，以及这个请求完成后的回调函数等信息。事件处理器收到请求后，处理这个请求，完成后转发完成事件给相应的事件处理器或者回调函数。

改进实现的模拟Proactor模式：

* 等待事件（Proactor的工作）
* 读数据（Proactor的工作）
* 事件完成后触发完成事件（Proactor的工作）
* 完成事件（用户的工作）

Proactor模式关注的是由操作系统完成异步非阻塞的操作后返回的结果。



## 参考

[参考一：两种IO模式Proactor与Reactor](https://yq.aliyun.com/ziliao/29133)

[参考二：Java NIO浅析](https://tech.meituan.com/nio.html)
